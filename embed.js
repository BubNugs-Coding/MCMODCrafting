// Recipe Embed Tool
// -------------------------------------------------------------
// Loads recipe JSON files (folders or files) in the browser and
// generates a self-contained recipes.js bundle that the viewer
// can load without accessing the filesystem. No network involved.

const els = {
  folderInput: document.getElementById('folderInput'),
  filesInput: document.getElementById('filesInput'),
  dropZone: document.getElementById('dropZone'),
  loadStatus: document.getElementById('loadStatus'),
  exportBtn: document.getElementById('exportBtn'),
};

let collected = [];

const isJsonFile = (f) => f && f.name && f.name.toLowerCase().endsWith('.json');

function setStatus(msg, isError = false) {
  els.loadStatus.textContent = msg || '';
  els.loadStatus.classList.toggle('error', !!isError);
}

function reset() {
  collected = [];
  els.exportBtn.disabled = true;
}

async function readFiles(fileList) {
  const files = Array.from(fileList || []).filter(isJsonFile);
  if (!files.length) return { total: 0, parsed: 0, errors: 0 };
  setStatus(`Reading ${files.length} files...`);
  let parsed = 0, errors = 0;
  for (const f of files) {
    try {
      const text = await f.text();
      try {
        const json = JSON.parse(text);
        if (Array.isArray(json)) {
          json.forEach((r, i) => collected.push({ ...r, __source: `${f.webkitRelativePath || f.name}#${i}` }));
        } else {
          collected.push({ ...json, __source: f.webkitRelativePath || f.name });
        }
        parsed++;
      } catch (e) {
        console.warn('JSON parse failed', f.name, e);
        errors++;
      }
    } catch (e) {
      console.warn('Read failed', f.name, e);
      errors++;
    }
  }
  els.exportBtn.disabled = collected.length === 0;
  setStatus(`Loaded ${parsed}/${files.length} files. Collected ${collected.length} recipes. ${errors ? errors + ' errors.' : ''}`);
  return { total: files.length, parsed, errors };
}

els.folderInput.addEventListener('change', async (e) => {
  reset();
  await readFiles(e.target.files);
});

els.filesInput.addEventListener('change', async (e) => {
  reset();
  await readFiles(e.target.files);
});

function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
['dragenter','dragover','dragleave','drop'].forEach(ev => {
  els.dropZone.addEventListener(ev, preventDefaults, false);
});
['dragenter','dragover'].forEach(ev => {
  els.dropZone.addEventListener(ev, () => els.dropZone.classList.add('drag'));
});
['dragleave','drop'].forEach(ev => {
  els.dropZone.addEventListener(ev, () => els.dropZone.classList.remove('drag'));
});
els.dropZone.addEventListener('drop', async (e) => {
  reset();
  const dt = e.dataTransfer;
  if (dt?.items && dt.items.length && dt.items[0].webkitGetAsEntry) {
    const items = Array.from(dt.items);
    const files = await traverseItems(items);
    await readFiles(files);
  } else {
    await readFiles(dt.files);
  }
});

// Traverse a drop of directories (Chrome/WebKit) into File objects
async function traverseItems(items) {
  const filePromises = [];
  for (const item of items) {
    const entry = item.webkitGetAsEntry && item.webkitGetAsEntry();
    if (!entry) continue;
    filePromises.push(...await traverseEntry(entry));
  }
  const files = await Promise.all(filePromises);
  return files.filter(Boolean);
}

// Recursively convert a FileSystemEntry into File objects
async function traverseEntry(entry) {
  if (entry.isFile) {
    return [new Promise((resolve) => entry.file(resolve))];
  }
  if (entry.isDirectory) {
    const reader = entry.createReader();
    const entries = await new Promise((resolve, reject) => reader.readEntries(resolve, reject));
    const nested = await Promise.all(entries.map(traverseEntry));
    return nested.flat();
  }
  return [];
}

els.exportBtn.addEventListener('click', () => {
  if (!collected.length) return;
  const header = '// Generated by Embed Tool. Place next to index.html\n';
  const payload = 'window.EMBEDDED_RECIPES = ' + JSON.stringify(collected) + ';\n';
  const blob = new Blob([header, payload], { type: 'application/javascript' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'recipes.js';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  setStatus(`Downloaded recipes.js with ${collected.length} recipes.`);
});
